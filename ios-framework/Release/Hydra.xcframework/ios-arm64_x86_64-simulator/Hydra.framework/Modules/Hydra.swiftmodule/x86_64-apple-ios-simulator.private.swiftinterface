// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.10 (swiftlang-5.10.0.13 clang-1500.3.9.4)
// swift-module-flags: -target x86_64-apple-ios9.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Onone -enable-bare-slash-regex -module-name Hydra
import Dispatch
import Foundation
@_exported import Hydra
import Swift
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
public enum PromiseError : Swift.Error {
  case timeout
  case rejected
  case invalidInput
  case invalidContext
  case attemptsFailed
  public static func == (a: Hydra.PromiseError, b: Hydra.PromiseError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol InvalidatableProtocol {
  var isCancelled: Swift.Bool { get }
}
open class InvalidationToken : Hydra.InvalidatableProtocol {
  public var isCancelled: Swift.Bool
  public func invalidate()
  public init()
  @objc deinit
}
public struct PromiseStatus {
  public let cancel: (() -> ())
  public var isCancelled: Swift.Bool {
    get
  }
}
public enum Context {
  case main
  case userInteractive
  case userInitiated
  case utility
  case background
  case custom(queue: Dispatch.DispatchQueue)
  public var queue: Dispatch.DispatchQueue {
    get
  }
}
public class Promise<Value> {
  public typealias Resolved = (Value) -> ()
  public typealias Rejector = (any Swift.Error) -> ()
  public typealias Body = ((_ resolve: @escaping Hydra.Promise<Value>.Resolved, _ reject: @escaping Hydra.Promise<Value>.Rejector, _ promise: Hydra.PromiseStatus) throws -> ())
  public var name: Swift.String?
  public var operation: Hydra.PromiseStatus {
    get
    set
  }
  public var result: Value? {
    get
  }
  public var error: (any Swift.Error)? {
    get
  }
  public var isPending: Swift.Bool {
    get
  }
  public init(resolved value: Value)
  public init()
  public init(rejected error: any Swift.Error)
  public init(in context: Hydra.Context? = nil, token: Hydra.InvalidationToken? = nil, _ body: @escaping Hydra.Promise<Value>.Body)
  @objc deinit
  public func resolve(_ value: Value)
  public func reject(_ error: any Swift.Error)
  public func cancel()
  public var isCancelled: Swift.Bool {
    get
  }
  public var void: Hydra.Promise<Swift.Void> {
    get
  }
}
public func all<L>(_ promises: Hydra.Promise<L>..., concurrency: Swift.UInt = UInt.max) -> Hydra.Promise<[L]>
public func all<L, S>(_ promises: S, concurrency: Swift.UInt = UInt.max) -> Hydra.Promise<[L]> where S : Swift.Sequence, S.Element == Hydra.Promise<L>
extension Hydra.Promise {
  @discardableResult
  public func always(in context: Hydra.Context? = nil, body: @escaping () throws -> Swift.Void) -> Hydra.Promise<Value>
}
public func any<L>(in context: Hydra.Context? = nil, _ promises: Hydra.Promise<L>...) -> Hydra.Promise<L>
public func any<L>(in context: Hydra.Context? = nil, _ promises: [Hydra.Promise<L>]) -> Hydra.Promise<L>
public func async<T>(in context: Hydra.Context? = nil, token: Hydra.InvalidationToken? = nil, _ body: @escaping ((_ status: Hydra.PromiseStatus) throws -> (T))) -> Hydra.Promise<T>
public func async(in context: Hydra.Context, after: Foundation.TimeInterval? = nil, _ block: @escaping () -> ())
prefix operator ..
prefix public func .. <T>(promise: Hydra.Promise<T>) throws -> T
prefix operator ..!
prefix public func ..! <T>(promise: Hydra.Promise<T>) -> T?
@discardableResult
@available(*, deprecated, renamed: "Hydra.await")
public func await<T>(in context: Hydra.Context? = nil, _ promise: Hydra.Promise<T>) throws -> T
@discardableResult
@available(*, deprecated, renamed: "Hydra.await")
public func await<T>(in context: Hydra.Context = .background, _ body: @escaping ((_ fulfill: @escaping (T) -> (), _ reject: @escaping (any Swift.Error) -> (), _ operation: Hydra.PromiseStatus) throws -> ())) throws -> T
public enum Hydra {
  @discardableResult
  public static func await<T>(in context: Hydra.Context? = nil, _ promise: Hydra.Promise<T>) throws -> T
  @discardableResult
  public static func await<T>(in context: Hydra.Context = .background, _ body: @escaping ((_ fulfill: @escaping (T) -> (), _ reject: @escaping (any Swift.Error) -> (), _ operation: Hydra.PromiseStatus) throws -> ())) throws -> T
}
extension Hydra.Promise {
  @discardableResult
  public func cancelled(in context: Hydra.Context? = nil, _ body: @escaping (() -> (Swift.Void))) -> Hydra.Promise<Swift.Void>
}
extension Hydra.Promise {
  @discardableResult
  public func `catch`(in context: Hydra.Context? = nil, _ body: @escaping ((any Swift.Error) throws -> ())) -> Hydra.Promise<Swift.Void>
}
extension Hydra.Promise {
  public func `defer`(in context: Hydra.Context? = nil, _ seconds: Foundation.TimeInterval) -> Hydra.Promise<Value>
}
public enum PromiseResolveType {
  case parallel
  case series
  public static func == (a: Hydra.PromiseResolveType, b: Hydra.PromiseResolveType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public func map<A, B, S>(_ context: Hydra.Context? = nil, as type: Hydra.PromiseResolveType, _ items: S, _ transform: @escaping (A) throws -> Hydra.Promise<B>) -> Hydra.Promise<[B]> where A == S.Element, S : Swift.Sequence
public func map_series<A, B, S>(context: Hydra.Context, items: S, transform: @escaping (A) throws -> Hydra.Promise<B>) -> Hydra.Promise<[B]> where A == S.Element, S : Swift.Sequence
extension Hydra.Promise {
  indirect public enum Observer {
    public typealias ResolveObserver = ((Value) -> ())
    public typealias RejectObserver = ((any Swift.Error) -> ())
    public typealias CancelObserver = (() -> ())
    case onResolve(Hydra.Context, Hydra.Promise<Value>.Observer.ResolveObserver)
    case onReject(Hydra.Context, Hydra.Promise<Value>.Observer.RejectObserver)
    case onCancel(Hydra.Context, Hydra.Promise<Value>.Observer.CancelObserver)
  }
}
extension Hydra.Promise {
  public func pass<A>(in context: Hydra.Context? = nil, _ body: @escaping (Value) throws -> Hydra.Promise<A>) -> Hydra.Promise<Value>
  public func pass(in context: Hydra.Context? = nil, _ handler: @escaping (Value) throws -> Swift.Void) -> Hydra.Promise<Value>
}
extension Hydra.Promise {
  public func recover(in context: Hydra.Context? = nil, _ body: @escaping (any Swift.Error) throws -> Hydra.Promise<Value>) -> Hydra.Promise<Value>
}
public func reduce<A, I, S>(in context: Hydra.Context? = nil, _ items: S, _ initial: I, _ transform: @escaping (I, A) throws -> Hydra.Promise<I>) -> Hydra.Promise<I> where A == S.Element, S : Swift.Sequence
extension Hydra.Promise {
  public func retry(_ attempts: Swift.Int = 3, delay: Foundation.TimeInterval = 0, _ condition: @escaping ((Swift.Int, any Swift.Error) throws -> Swift.Bool) = { _,_ in true }) -> Hydra.Promise<Value>
}
extension Hydra.Promise {
  public func retryWhen(_ attempts: Swift.Int = 3, delay: Foundation.TimeInterval = 0, _ condition: @escaping ((Swift.Int, any Swift.Error) -> Hydra.Promise<Swift.Bool>) = { _,_ in Promise<Bool>(resolved: true) }) -> Hydra.Promise<Value>
}
extension Hydra.Promise {
  @discardableResult
  public func then<N>(in context: Hydra.Context? = nil, _ body: @escaping ((Value) throws -> N)) -> Hydra.Promise<N>
  @discardableResult
  public func then<N>(in context: Hydra.Context? = nil, _ body: @escaping ((Value) throws -> (Hydra.Promise<N>))) -> Hydra.Promise<N>
  @discardableResult
  public func then(in context: Hydra.Context? = nil, _ body: @escaping ((Value) throws -> ())) -> Hydra.Promise<Value>
}
extension Hydra.Promise {
  public func timeout(in context: Hydra.Context? = nil, timeout: Foundation.TimeInterval, error: (any Swift.Error)? = nil) -> Hydra.Promise<Value>
}
extension Hydra.Promise {
  public func validate(in context: Hydra.Context? = nil, _ validate: @escaping ((Value) throws -> (Swift.Bool))) -> Hydra.Promise<Value>
}
public func zip<A, B>(in context: Hydra.Context? = nil, _ a: Hydra.Promise<A>, _ b: Hydra.Promise<B>) -> Hydra.Promise<(A, B)>
public func zip<A, B, C>(in context: Hydra.Context? = nil, a: Hydra.Promise<A>, b: Hydra.Promise<B>, c: Hydra.Promise<C>) -> Hydra.Promise<(A, B, C)>
public func zip<A, B, C, D>(in context: Hydra.Context? = nil, a: Hydra.Promise<A>, b: Hydra.Promise<B>, c: Hydra.Promise<C>, d: Hydra.Promise<D>) -> Hydra.Promise<(A, B, C, D)>
extension Hydra.PromiseError : Swift.Equatable {}
extension Hydra.PromiseError : Swift.Hashable {}
extension Hydra.PromiseResolveType : Swift.Equatable {}
extension Hydra.PromiseResolveType : Swift.Hashable {}
